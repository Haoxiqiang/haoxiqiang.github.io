---
layout: post
title:  问题整理二
date:   2016-01-19 16:50:36
author: 郝锡强
categories: blog
letex: false
tags: [android]
---
对于`WebView`来讲,不要直接在`xml`中使用,因为这样,在`Activity`销毁的时候,内存也不会被释放,一些值得去做的方法:
{% highlight java %}
//使用ApplicationContext初始化
WebView webView = new WebView(getApplicationContext());
//如果在 fragment 里面
@Override
public void onDetach(){
    super.onDetach();
    webView.removeAllViews();
    webView.destroy();
}
//清单文件中统一管理进程
<application
    android:process="com.processkill.p1">
    <activity
        android:name="com.processkill.A"
        android:process="com.processkill.p2">
    </activity>
    <activity
        android:name="com.processkill.B"
        android:process="com.processkill.p3">
    </activity>
</application>
{% endhighlight %}

<!-- more -->

`Romain Guy`写过这样一个文章[avoid-memory-leaks-on-android](http://www.curious-creature.com/2008/12/18/avoid-memory-leaks-on-android/).当然现在看起来有些过时了,现在会在设置第二次的时候检查并释放前一个引用,当然我们应该避免这样使用 `static` 关键字
{% highlight java %}
...
/*
 * Regardless of whether we're setting a new background or not, we want
 * to clear the previous drawable.
 */
if (mBackground != null) {
    mBackground.setCallback(null);
    unscheduleDrawable(mBackground);
}
...
{% endhighlight %}

`WebView`加载中在链接上添加参数,需要注意的是要对参数编码,以前可能使用的是`NameValuePair`,`API 23`以后会提示`@deprecated`,其实这里根据自己的喜好习惯可以自己去操作,比如
{% highlight java %}
 JSONObject json = new JSONObject();
 Iterator<String> keys = json.keys();
 StringBuilder stringBuilder = new StringBuilder();
 try {
     while (keys.hasNext()) {
         String key = keys.next();
         String value = json.optString(key);
         if (value != null) {
             stringBuilder.append(URLEncoder.encode(key, "UTF-8"))
                     .append("=")
                     .append(URLEncoder.encode(value, "UTF-8"));
         }
     }
 } catch (UnsupportedEncodingException e) {
     e.printStackTrace();
 }
{% endhighlight %}
本质还是一样的,原来的使用方式中,会有两次 `toString`的操作,也是类似的操作,具体不写了